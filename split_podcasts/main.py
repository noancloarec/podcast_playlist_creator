from argparse import ArgumentParser, Namespace
from argparse import ArgumentParser, Namespace
from math import ceil
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Iterator

import ffmpeg
from sympy import pprint

from audio_operations import convert_to_mp3, split_audio, merge_mp3s
from podcast import get_podcasts, Podcast
from text_to_speech import generate_part_title_audio


def parse_args() -> Namespace:
    parser = ArgumentParser(description="Simple calculator")
    parser.add_argument(
        "input_folder",
        type=str,
        help="Input folder where audio files and feed.sample.xml files are downloaded",
    )
    parser.add_argument("output_folder", type=str, help="Output folder")
    return parser.parse_args()


def ensure_podcast_is_mp3(podcast: Podcast, input_dir: Path) -> None:
    """
    If the mp3 in the podcast does not exist in input_dir, tries to convert the corresponding .m4a or .wav file
    If there is no corresponding file, the programm fails
    :param podcast: the podcast from which the mp3 must be generated
    :param input_dir: the input dir where audio files are stored, the mp3 files will be written here
    """
    podcast_path_mp3 = input_dir / podcast.filename
    if podcast_path_mp3.exists():
        return
    audio_formats_supported = [".wav", ".m4a"]
    try:
        podcast_in_another_format = next(
            filename
            for filename in podcast_path_mp3.parent.iterdir()
            if filename.stem == podcast_path_mp3.stem
            and filename.suffix in audio_formats_supported
        )
    except StopIteration:
        print(
            f"Cannot find {podcast_path_mp3} and there are no candidate in format {audio_formats_supported} to be converted to mp3"
        )
        exit(1)
    print(f"Converting {podcast_in_another_format} to mp3, this may take some time")
    convert_to_mp3(podcast_in_another_format, podcast_path_mp3)


def split_podcast_and_add_title_at_start(podcast: Podcast, input_dir:Path, output_dir: Path, part_duration:int)->None:
    """
    Split the podcast in several parts of a given duration, add the title pronounced at the beginning of each podcast
    :param podcast: the podcast to be splat
    :param input_dir: the dir where the podcast can be found
    :param output_dir: the dir where to write the podcast parts
    """
    podcast_stem = str(Path(podcast.filename).stem)
    with TemporaryDirectory() as temp_dir_str:
        temp_dir = Path(temp_dir_str)

        for part_number, total_parts, part_filename in split_audio(
                input_dir / podcast.filename, temp_dir, part_duration
        ):
            title_audio = temp_dir / (
                    podcast_stem + f"_partie_{part_number:02}_title.mp3"
            )

            generate_part_title_audio(
                f"Partie {part_number}/{total_parts} de {podcast.title}",
                title_audio,
            )

            merge_mp3s(
                title_audio,
                part_filename,
                output_dir / part_filename.name,
            )


def main():
    """
    From a folder containing podcasts and the rss feed sample generated by the web extension
    Cut each podcasts into several n minutes parts, append a short audio at the beginning of each part saying
    something like "Partie 1/4 de {podcast_title}"
    Podcasts are made more enjoyable on a device with only 2 buttons next track/previous track

    """
    args = parse_args()
    input_dir = Path(args.input_folder)
    output_dir = Path(args.output_folder)
    output_dir.mkdir(exist_ok=True)

    podcasts_to_split = get_podcasts(
        input_dir / "feed.sample.xml",
    )
    for podcast in podcasts_to_split:
        ensure_podcast_is_mp3(podcast, input_dir)

    for podcast in podcasts_to_split:
        split_podcast_and_add_title_at_start(podcast, input_dir, output_dir, 600)

if __name__ == "__main__":
    main()
